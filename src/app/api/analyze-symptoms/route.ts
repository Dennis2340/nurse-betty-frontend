/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextResponse } from 'next/server';
import { z } from 'zod';
import { OpenAI } from 'openai';

const client = new OpenAI({
  baseURL: 'https://router.huggingface.co/featherless-ai/v1',
  apiKey: process.env.HF_TOKEN,
});

const schema = z.object({
  symptoms: z.string().describe('Comma-separated symptoms like chest pain, nausea'),
  guidelineContext: z
    .array(
      z.object({
        text: z.string(),
        section: z.string(),
        category: z.string(),
        entity: z.string(),
        severity_level: z.string().nullable(),
      }),
    )
    .nullable()
    .describe('Retrieved guideline chunks from STG'),
});

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { symptoms, guidelineContext } = schema.parse(body);

    const prompt = `
Analyze the following symptoms and guideline context to suggest appropriate next steps for the patient. Use the Sierra Leone Standard Treatment Guidelines (STG) to inform your recommendations, which may include e-prescriptions, lab tests, specialist referrals, or self-care instructions.

Symptoms: ${symptoms}

Guideline Context:
${guidelineContext && guidelineContext.length > 0 ? guidelineContext.map(chunk => `- Section: ${chunk.section}\n  Text: ${chunk.text}\n  Category: ${chunk.category}\n  Entity: ${chunk.entity}\n  Severity: ${chunk.severity_level || 'N/A'}`).join('\n') : 'No specific guideline context provided.'}

Return your analysis and recommendations in a structured JSON format with fields: ePrescription (string), labTests (array), specialistReferral (string), selfCare (string), and explanation (string).
`;

    const chatCompletion = await client.chat.completions.create({
      model: 'Intelligent-Internet/II-Medical-8B-1706',
      messages: [{ role: 'user', content: prompt }],
    });

    const analysis = chatCompletion.choices[0].message.content;

    // Log the raw response for debugging
    console.log('Raw response from medical model:', analysis);

    // Check if the response is valid JSON
    if (analysis && (analysis.trim().startsWith('{') || analysis.trim().startsWith('['))) {
      try {
        const parsed = JSON.parse(analysis);
        return NextResponse.json({
          ePrescription: parsed.ePrescription || '',
          labTests: parsed.labTests || [],
          specialistReferral: parsed.specialistReferral || '',
          selfCare: parsed.selfCare || '',
          explanation: parsed.explanation || 'No detailed explanation provided by the model.',
        });
      } catch (e) {
        console.error('Error parsing JSON despite valid start:', e);
      }
    }

    // Fallback for non-JSON responses
    console.warn('Response is not valid JSON, using fallback parsing.');
    interface MedicalRecommendations {
      ePrescription: string;
      labTests: string[];
      specialistReferral: string;
      selfCare: string;
      explanation: string;
    }

    const recommendations: MedicalRecommendations = {
      ePrescription: '',
      labTests: [],
      specialistReferral: '',
      selfCare: '',
      explanation: analysis || 'Analysis generated by the medical model.',
    };

    // Extract information from plain text if possible
    if (analysis) {
      const text = analysis.toLowerCase();
      if (text.includes('prescribe')) {
        recommendations.ePrescription = analysis.match(/prescribe (.+?)(?:,|$|\.)/i)?.[1] || '';
      }
      if (text.includes('lab test')) {
        recommendations.labTests = analysis.match(/lab test: (.+?)(?:,|$|\.)/gi)?.map(match => match.split(': ')[1]) || [];
      }
      if (text.includes('refer to')) {
        recommendations.specialistReferral = analysis.match(/refer to (.+?)(?:,|$|\.)/i)?.[1] || '';
      }
      if (text.includes('self-care')) {
        recommendations.selfCare = analysis.match(/self-care: (.+?)(?:,|$|\.)/i)?.[1] || '';
      }
    }

    return NextResponse.json(recommendations);

  } catch (error: any) {
    console.error('Error in analyze-symptoms:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}